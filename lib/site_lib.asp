<%
'--------------------------------------------------------------------
' site_lib.asp
'	This library should be included on every ASP page on the site.
'	It includes the standard include files to do basic things such
'	as database access and processing form/query string variables.
'	Additionally, the code below manages dynamic content that is
'	stored in the database.
'
' AUTH:	Ken Richards
' DATE:	07/25/2001
'
' Copyright (C) 2002 Orvado Technologies (http://www.orvado.com)
'
' This program is free software; you can redistribute it and/or
' modify it under the terms of the GNU General Public License
' as published by the Free Software Foundation; either version 2
' of the License, or (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
'--------------------------------------------------------------------

' for timing how long it takes a page to process
Dim steTimer : steTimer = Timer

Dim steObjContentType	' dictionary of form object content-types
Dim steObjFilenames		' dictionary of uploaded files
Dim steObjBlob			' dictionary of blobs (binary large objects)
Dim steObjForm			' dictionary of form variables
Dim steWasUpload		' boolean - has the form been posted & parsed?
Dim steErrorMsg			' error message generated by library
Dim steReplaceFind		' string in path to replace
Dim steReplaceWith		' string in path to replace with
Dim steOverwrite		' overwrite the existing file (if any)
Dim stePrependPrefix	' prefix to prepend to uploaded filenames
Dim steUploadMime		' acceptable mime types for upload
Dim steUploadExt		' restrict filename extensions for upload
Dim steUploadMax		' maximum bytes for a single uploaded file
Dim steUploadRename		' pathname for the uploaded and renamed file
Dim steIsMultipartPost	' was a multi-part post done?

steWasUpload = False
steOverwrite = False
steUploadMime = "image/jpg; image/jpeg; image/gif; image/png; image/x-png;"
steUploadExt = "jpg; gif; png;"
steUploadMax = "8192"		' 8K maximum uploaded file size
steIsMultipartPost = steCheckMultipartPost

' try to prevent caching pages in Internet Explorer
Response.CacheControl = "no-cache"
Response.AddHeader "Pragma", "no-cache"
Response.Expires = -1

' load the site configuration from global.asa / database (if nec)
' needed when not running ASP Nuke as virtual directory or site root
If Application("steLoadConfig") = "" Then steLoadConfig
%>
<!-- #include file="ado_lib.asp" -->
<!-- #include file="module_lib.asp" -->
<!-- #include file="lang_lib.asp" -->
<%

'------------------------------------------------------------------
' retrieve the value of a querystring / form field

Function steForm(sField)
	If IsObject(steObjForm) Then
		If steObjFilenames(sField) <> "" Then
			steForm = steObjFilenames(sField)
		Else
			steForm = steObjForm(sField)
		End If
	ElseIf Not steIsMultipartPost Then
		If Request.QueryString(sField) <> "" Then
			steForm = Request.QueryString(sField)
		Else
			steForm = Request.Form(sField)
		End If
	Else
		' can't read from form because BinaryRead may have been called
		steForm = Request.QueryString(sField)
	End If
End Function

'------------------------------------------------------------------
' retrieve an integer value from the querystring / form collection

Function steNForm(sField)
	Dim nValue

	nValue = steForm(sField)
	On Error Resume Next
	If IsNumeric(nValue) And CStr(nValue) <> "" Then steNForm = CInt(nValue) Else steNForm = 0
	If Err.Number <> 0 Then steNForm = 0
	On Error Goto 0	
End Function

'------------------------------------------------------------------
' retrieve a floating point value from the querystring / form collection

Function steFForm(sField)
	Dim fValue

	fValue = steForm(sField)
	On Error Resume Next
	If IsNumeric(fValue) And CStr(fValue) <> "" Then steFForm = CDbl(fValue) Else steFForm = 0
	If Err.Number <> 0 Then steFForm = 0
	On Error Goto 0	
End Function

'------------------------------------------------------------------
' retrieve a server.URLEncoded querystring / form collection

Function steEncForm(sField)
	If IsObject(steObjForm) Then
		If steObjFilenames(sField) <> "" Then
			steEncForm = Server.HTMLEncode(steObjFilenames(sField))
		Else
			steEncForm = Server.HTMLEncode(steObjForm(sField))
		End If
	ElseIf Not steIsMultipartPost Then
		If Request.QueryString(sField) <> "" Then
			steEncForm = Server.HTMLEncode(Request.QueryString(sField))
		Else
			steEncForm = Server.HTMLEncode(Request.Form(sField))
		End If	
	Else
		' can't read from form because BinaryRead may have been called
		steEncForm = Server.HTMLEncode(Request.QueryString(sField))
	End If
End Function

'------------------------------------------------------------------
' retrieve a querystring / form collection value stripped of code/HTML

Function steStripForm(sField)
	If IsObject(steObjForm) Then
		If steObjFilenames(sField) <> "" Then
			steStripForm = steStripHTML(steObjFilenames(sField))
		Else
			steStripForm = steStripHTML(steObjForm(sField))
		End If
	ElseIf Not steIsMultipartPost Then
		If Request.QueryString(sField) <> "" Then
			steStripForm = steStripHTML(Request.QueryString(sField))
		Else
			steStripForm = steStripHTML(Request.Form(sField))
		End If	
	Else
		' can't read from form because BinaryRead may have been called
		steStripForm = steStripHTML(Request.QueryString(sField))
	End If
End Function

'------------------------------------------------------------------
' retrieve a server.URLEncoded querystring / form collection

Function steEncStripForm(sField)
	If IsObject(steObjForm) Then
		If steObjFilenames(sField) <> "" Then
			steEncStripForm =Server.HTMLEncode(steStripHTML(steObjFilenames(sField)))
		Else
			steEncStripForm = Server.HTMLEncode(steStripHTML(steObjForm(sField)))
		End If
	ElseIf Not steIsMultipartPost Then
		If Request.QueryString(sField) <> "" Then
			steEncStripForm = Server.HTMLEncode(steStripHTML(Request.QueryString(sField)))
		Else
			steEncStripForm = Server.HTMLEncode(steStripHTML(Request.Form(sField)))
		End If	
	Else
		' can't read from form because BinaryRead may have been called
		steEncStripForm = Server.HTMLEncode(steStripHTML(Request.QueryString(sField)))
	End If
End Function

'------------------------------------------------------------------
' retrieve an SQL quoted form field for doing database insert/update

Function steQForm(sField)
	If Application("ADO_DATABASETYPE") = "MySQL" Then
		steQForm = "'" & Replace(Replace(steForm(sField), "'", "''"), "\", "\\") & "'"		
	Else 
		steQForm = "'" & Replace(steForm(sField), "'", "''") & "'"
	End If
End Function

'------------------------------------------------------------------
' retrieve a list of SQL quoted form field for doing database
' inserts and updates

Function steQFormList(sFieldList)
	Dim aField, sList, I
	aField = Split(sFieldList, ",")
	For I = 0 To UBound(aField)
		If I > 0 Then sList = sList & ","
		sList = sList & steQForm(aField(I))
	Next
	steQFormList = sList
End Function

'------------------------------------------------------------------
' retrieve the value of a database field (edit mode) or form value (add mode)

Function steRecordValue(rs, sField)
	' attempt to retrieve value from querystring or form value first
	If steForm(sField) <> "" Then
		steRecordValue = steForm(sField)
		Exit Function
	End If
	' if in edit mode - retrieve the value for the edit recordset
	If IsObject(rs) Then
		If Not rs.EOF Then
			If IsObject(rs.Fields(sField)) Then
				steRecordValue = rs.Fields(sField).Value
				Exit Function
			Else
				steRecordValue = sField & " DOES NOT EXIST"
				Exit Function
			End If
		End If
	End If
End Function

'------------------------------------------------------------------
' retrieve an integer value from a database field (edit mode) or form value (add mode)

Function steNRecordValue(rs, sField)
	Dim nValue

	nValue = steRecordValue(rs, sField)
	If IsNumeric(nValue) And nValue & "" <> "" Then
		steNRecordValue = CInt(nValue)
	Else
		steNRecordValue = 0
	End If
End Function

'------------------------------------------------------------------
' retrieve the HTML encoded value of a field in the recordset

Function steRecordEncValue(rs, sField)
	steRecordEncValue = Server.HTMLEncode(steRecordValue(rs, sField) & "")
End Function

'------------------------------------------------------------------
' retrieve a boolean value from a bit or tinyint field in the recordset

Function steRecordBoolValue(rs, sField)
	Dim sValue
	sValue = CStr(steRecordValue(rs, sField))
	Select Case sValue
		Case "True", "1" : steRecordBoolValue = True
		Case Else : steRecordBoolValue = False
	End Select
End Function

'------------------------------------------------------------------
' return a date value from the database

Function steDateValue(rs, sField)
	Dim sDate

	sDate = steRecordValue(rs, sField)
	If IsDate(sDate) Then
		steDateValue = FormatDateTime(sDate, vbGeneralDate)
	Else
		steDateValue = "<I>n/a</I>"
	End If
End Function

'----------------------------------------------------------------------------
' steStripHTML
'	Strip out all HTML from the content parameter (passed by ref)

Function steStripHTML(ByRef sContent)
	Dim re

	Set re = New RegExp
	' first strip out script blocks
	re.Pattern = "<script[^>]*>[\s\S]*?</script>"
	re.IgnoreCase = True
	re.Global = True
	sContent = re.Replace(sContent, "")
	' and next comments
	re.Pattern = "<!--[\s\S]*?-->"
	sContent = re.Replace(sContent, "")
	' and also ASP code blocks (just-in-case)
	re.Pattern = "<" & "\%[\s\S]*?\%" & ">"
	sContent = re.Replace(sContent, "")
	' and now any HTML tag
	re.Pattern = "</?(A|ABBR|ABOVE|ACRONYM|ADDRESS|APPLET|ARRAY|AREA|AUDIOSCOPE|B|BASE|BASEFONT|BDO|BGSOUND|BIG|BLACKFACE|BLINK|BLOCKQUOTE|BODY|BOX|BQ|BR|BUTTON|CAPTION|CENTER|CITE|CODE|COL|COLGROUP|COMMENT|DD|DEL|DFN|DIR|DIV|DT|DL|DT|EM|EMBED|FIELDSET|FIG|FN|FONT|FORM|FRAME|FRAMESET|H1|H2|H3|H4|H5|H6|HEAD|HR|HTML|I|IFRAME|ILAYER|IMG|INPUT|INS|ISINDEX|KBD|KEYGEN|LABEL|LAYER|LEGEND|LI|LINK|LISTING|MAP|MARQUEE|MENU|META|MULTICOL|NEXTID|NOBR|NOFRAMES|NOLAYER|NOTE|NOSCRIPT|NOSMARTQUOTES|OBJECT|OL|OPTION|OPTGROUP|P|PARAM|PLAINTEXT|PRE|Q|QUOTE|RANGE|ROOT|RT|RUBY|S|SAMP|SCRIPT|SELECT|SERVER|SHADOW|SIDEBAR|SOUND|SPACER|SMALL|SPAN|SQRT|STRIKE|STRONG|STYLE|SUB|SUP|TABLE|TBODY|TD|TEXT|TEXTAREA|TFOOT|TH|THEAD|TITLE|TR|TT|U|UL|VAR|WBR|XML|XMP)(\s[^>]*)?>"
	' re.Pattern = "<[^>]*>"
	sContent = re.Replace(sContent, "")
	' replace multiple carriage returns with a single
	re.Pattern = "(\n\s*){2,}"
	sContent = re.Replace(sContent, vbCrLf & vbCrLf)
	' trim leading / trailing
	re.Pattern = "^\s+"
	sContent = re.Replace(sContent, "")
	re.Pattern = "\s+$"
	steStripHTML = re.Replace(sContent, "")
End Function

'----------------------------------------------------------------
'Byte string to Unicode string conversion

Function steBStr2UStr(BStr)
	Dim nPos
	steBStr2UStr = ""
	For nPos = 1 to LenB(BStr)
		steBStr2UStr = steBStr2UStr & Chr(AscB(MidB(BStr, nPos, 1)))
	Next
End Function

'----------------------------------------------------------------
'Unicode string to Byte string conversion

Function steUStr2Bstr(UStr)
	Dim nPos, sChar

	steUStr2Bstr = ""
	For nPos = 1 to Len(UStr)
		sChar = Mid(UStr, nPos, 1)
		steUStr2Bstr = steUStr2Bstr & ChrB(AscB(sChar))
	Next
End Function

'----------------------------------------------------------------
' URL decode a string

Function steURLDecode(sText)
	Dim sSource, sTemp, sResult

	Dim nPos
	sSource = Replace(sText, "+", " ")
	For nPos = 1 To Len(sSource)
	    sTemp = Mid(sSource, nPos, 1)
	    If sTemp = "%" Then
			If nPos + 2 < Len(sSource) Then
				sResult = sResult & Chr(CInt("&H" & Mid(sSource, nPos + 1, 2)))
				nPos = nPos + 2
			End If
		Else
			sResult = sResult & sTemp
		End If
	Next
	steURLDecode = sResult
End Function

'----------------------------------------------------------------
' Parse the contents of a request (posted with the attribute:
' enctype="multipart/form-data")

Sub steParseRequest(sErrorMsg)
	Dim nTotalBytes, nPosBeg, nPosEnd
	Dim nPosBoundary, nPosTmp, nPosFileName
	Dim sBRequest, sBBoundary, sBContent
	Dim sName, sFileName, sContentType
	Dim strValue, sTemp
	Dim objFile

	' create the hashtables to store form information
	Set steObjContentType = Server.CreateObject("Scripting.Dictionary")
	Set steObjFilenames = Server.CreateObject("Scripting.Dictionary")
	Set steObjBlob = Server.CreateObject("Scripting.Dictionary")
	Set steObjForm = Server.CreateObject("Scripting.Dictionary")

	'Grab the entire contents of the Request as a Byte string
	nTotalBytes = Request.TotalBytes
	sBRequest = Request.BinaryRead(nTotalBytes)
	steWasUpload = True

	'Find the first Boundary
	nPosBeg = 1
	nPosEnd = _
	    InStrB(nPosBeg, sBRequest, steUStr2Bstr(Chr(13)))
	If nPosEnd > 0 Then
		sBBoundary = _
	        MidB(sBRequest, nPosBeg, nPosEnd - nPosBeg)
		nPosBoundary = InStrB(1, sBRequest, sBBoundary)
	End If
	' was form submitted without ENCTYPE="multipart/form-data"?
	If sBBoundary = "" Then
		' YES - we can no longer access the Request.Form collection,
		' parse the request and populate the form collection
		nPosBeg = 1
		nPosEnd = InStrB(nPosBeg, sBRequest, steUStr2Bstr("&"))
		Do While nPosBeg < LenB(sBRequest)
			' parse the element and add it to the collection
			sTemp = steBStr2UStr(MidB(sBRequest, nPosBeg, nPosEnd - nPosBeg))
			nPosTmp = InStr(1, sTemp, "=")
			sName = steURLDecode(Left(sTemp, nPosTmp - 1))
			strValue = steURLDecode(Right(sTemp, Len(sTemp) - nPosTmp))
			steObjForm.Add sName, strValue

			' find the next element
			nPosBeg = nPosEnd + 1
			nPosEnd = InStrB(nPosBeg, sBRequest, steUStr2Bstr("&"))
			If nPosEnd = 0 Then
				nPosEnd = LenB(sBRequest) + 1
			End If
		Loop
	Else
		' NO - assume form submitted with ENCTYPE="multipart/form-data"
		' parse all boundaries, place values into the form or file dictionary.
		Do Until (nPosBoundary = InStrB(sBRequest, sBBoundary & steUStr2Bstr("--")))
			' get the post data properties
			nPosTmp = InStrB(nPosBoundary, sBRequest, steUStr2Bstr("Content-Disposition"))
			nPosTmp = InStrB(nPosTmp, sBRequest, steUStr2Bstr("name="))
			nPosBeg = nPosTmp + 6
			nPosEnd = InStrB(nPosBeg, sBRequest, steUStr2Bstr(Chr(34)))
			sName = steBStr2UStr(MidB(sBRequest, nPosBeg, nPosEnd - nPosBeg))
			' test for an element named 'filename'
			nPosFileName = InStrB(nPosBoundary, sBRequest, steUStr2Bstr("filename="))
	
			' if found, we have a file, otherwise it is a normal form element
		    If nPosFileName <> 0 And nPosFileName < InStrB(nPosEnd, sBRequest, sBBoundary) Then
				' it is a file. Get the FileName
				nPosBeg = nPosFileName + 10
				nPosEnd = InStrB(nPosBeg, sBRequest, steUStr2Bstr(chr(34)))
				sFileName = steBStr2UStr(MidB(sBRequest, nPosBeg, nPosEnd - nPosBeg))
				' get the ContentType
				nPosTmp = InStrB(nPosEnd, sBRequest, steUStr2Bstr("Content-Type:"))
				nPosBeg = nPosTmp + 14
				nPosEnd = InstrB(nPosBeg, sBRequest, steUStr2Bstr(chr(13)))
				sContentType = steBStr2UStr(MidB(sBRequest, nPosBeg, nPosEnd - nPosBeg))
				' check the acceptable filename extensions here
				If sFilename <> "" And Not (InStr(1, steUploadExt, Right(sFileName, 3) & ";") > 0) Then
					' sorry, filename extension not allowed
					sErrorMsg = sErrorMsg & "Invalid file (" & Mid(sFileName, InStrRev(sFileName, "\") + 1) & ") - Acceptable filename extensions:<BR>" & steUploadExt & ".<BR>"
				Else
					' check for acceptable mime encodings here
					If sFileName <> "" And Not (InStr(1, steUploadMime, sContentType & ";") > 0) Then
						' sorry, mime type not allowed
						sErrorMsg = sErrorMsg & "Invalid file: " & Mid(sFileName, InStrRev(sFileName, "\") + 1) & " (MIME: " & sContentType & ") - Acceptable file types:<BR>" & steUploadMime & ".<BR>"
					Else
						' get the Content
						nPosBeg = nPosEnd + 4
						nPosEnd = InStrB(nPosBeg, sBRequest, sBBoundary) - 2
						If nPosEnd - nPosBeg > steUploadMax Then
							' sorry, file is too large
							sErrorMsg = sErrorMsg & "Uploaded file (" &  Mid(sFileName, InStrRev(sFileName, "\") + 1) & ") too large (maximum " & steUploadMax & " bytes)<BR>"
						Else
							sBContent = MidB(sBRequest, nPosBeg, nPosEnd - nPosBeg)
							If sFileName <> "" And sBContent <> "" Then
								' create the file object and add it to the files collection
								steObjFileNames.Add sName, stePrependPrefix & Right(sFileName, Len(sFileName) - InStrRev(sFileName, "\"))
								steObjContentType.Add sName, sContentType
								steObjBlob.Add sName, sBContent
							End If
						End If
					End If
				End If
		    Else ' it is a form element
				' get the value of the form element
				nPosTmp = InStrB(nPosTmp, sBRequest, steUStr2Bstr(chr(13)))
				nPosBeg = nPosTmp + 4
				nPosEnd = InStrB(nPosBeg, sBRequest, sBBoundary) - 2
	
				strValue = steBStr2UStr(MidB(sBRequest, nPosBeg, nPosEnd - nPosBeg))
				' add the form element to the collection
				steObjForm.Add sName, strValue
			End If
			' move to next element
			nPosBoundary = InStrB(nPosBoundary + LenB(sBBoundary), sBRequest, sBBoundary)
		Loop
	End If
End Sub

'--------------------------------------------------------------------
' steCreateDirs
'	Create all directories necessary in the file path.  The path
'	supplied should be the virtual path to the new directory

Sub steCreateDirs(sPath)
	Dim sDir, oFSO, nPos

	On Error Resume Next
	Set oFSO = Server.CreateObject("Scripting.FileSystemObject")
	If Err.Number <> 0 Then
		steErrorMsg = "steCreateDirs(1) - Unable to create Scripting.FileSystemObject<br>" &_
			Err.Number & " - " & Err.Description
		Exit Sub
	End If
	On Error Goto 0
	nPos = InStr(2, sPath, "/")
	Do While nPos > 0
		sDir = Server.MapPath("/") & Left(sPath, nPos - 1)
		On Error Resume Next
		If Not oFSO.FolderExists(sDir) Then Call oFSO.CreateFolder(sDir)
		If Err.Number <> 0 Then
			steErrorMsg = "steCreateDirs(2) - Unable to create folder """ & sDir & """<br>" &_
				Err.Number & " - " & Err.Description
			Exit Sub
		End If
		On Error Goto 0
		nPos = Instr(nPos + 1, sPath, "/")
	Loop
	sDir = Server.MapPath("/") & sPath
	If Not oFSO.FolderExists(sDir) Then Call oFSO.CreateFolder(sDir)
	Set oFSO = Nothing
End Sub

'--------------------------------------------------------------------
' steFormPost
'	Saves all of the uploaded files to the path given in the method
'	parameter (sPath)
' RETURNS: True if a POST occurred, false otherwise

Function steFormPost(sPath, sErrorMsg)
	Dim oFSO, oFSOFile, sFilename, sDestFile
	Dim nPos, sFile

	If Request.ServerVariables("REQUEST_METHOD") = "POST" Then
		' parse the form data / file uploads into the dictionary objects
		steParseRequest sErrorMsg
		' create the necessary folders for this file
		steCreateDirs sPath
	
		Set oFSO = Server.CreateObject("Scripting.FileSystemObject")
		For Each sFile In steObjFileNames.Keys
			If Trim(steObjFileNames(sFile)) <> "" Then
				' build the filename on the local server (to save as)
				If steObjForm("uploadrename") <> "" Then sDestFile = steObjForm("uploadrename") & Mid(steObjFileNames(sFile), InStrRev(steObjFileNames(sFile), ".")) Else sDestFile = steObjFileNames(sFile)
				steUploadRename = Replace(oFSO.BuildPath(sPath, sDestFile), "\", "/")
				sFilename = Replace(Server.MapPath("/") & oFSO.BuildPath(sPath, sDestFile), "/", "\")
				If (steReplaceFind <> "") Then sFilename = Replace(sFilename, steReplaceFind, steReplaceWith)
	
				If oFSO.FileExists(sFilename) And Not steOverwrite _
					And (sPath & "/" & sDestFile) <> steObjForm("steallowoverwrite") Then
					sErrorMsg = sErrorMsg & "Sorry, File """ & sFilename & """ Already Exists (" & (sPath & "/" & sDestFile) & ")"
				Else
					On Error Resume Next
					Set oFSOFile = oFSO.CreateTextFile(sFilename, steOverwrite)
					If Err.Number <> 0 Then
						sErrorMsg = sErrorMsg & "Unable to create new file (" & Err.Description & "): " &_
							sFilename & "<BR>Key = " & sFile & "</B><BR>"
						steFormPost = False
						Exit Function
					End If
					On Error Goto 0
					For nPos = 1 to LenB(steObjBlob(sFile))
						oFSOFile.Write Chr(AscB(MidB(steObjBlob(sFile), nPos, 1)))
					Next
					oFSOFile.Close
				End If
			End If
		Next
		Set oFSO = Nothing
		steFormPost = True
	Else
		steFormPost = False
	End If
End Function

'----------------------------------------------------------------------------
' steLoadConfig
'	Load the site-wide configuration variables from tblApplicationVar in the
'	database defined by a connection string file.
'	Handles initializing global site configuration w/o executing global.asa

Sub steLoadConfig
	Dim sRootPath, sPath, sBasepath, nPos, oFSO, oFile, sContents, oRegex, oMatches, oMatch
	Dim sStat, rsVar

	' attempt to locate the global.asa configuration file
	Set oFSO = Server.CreateObject("Scripting.FileSystemObject")
	sRootPath = Server.MapPath("/")
	sPath = Server.MapPath(".")
	Do Until oFSO.FileExists(oFSO.BuildPath(sPath, "global.asa"))
		nPos = InStrRev(sPath, "\", Len(sPath) - 1)
		If nPos < 1 Then Exit Do
		sPath = Left(sPath, nPos)
	Loop
	' abort if the global.asa file was not found
	If Not oFSO.FileExists(oFSO.BuildPath(sPath, "global.asa")) Then
		Response.Write "<P><B class=""error"">Unable to locate global.asa configuration file... " & oFSO.BuildPath(sPath, "global.asa") & "</B></P>"
		Response.End
	End If

	' do we need to seek out the db connection string?
	If Application("adoConn_ConnectionString") = "" Then
		' read the contents of the file
		Set oFile = oFSO.OpenTextFile(oFSO.BuildPath(sPath, "global.asa"), 1)
		sContents = oFile.ReadAll
		oFile.Close
		' find the connection string variable
		Set oRegex = New RegExp
		oRegex.Pattern = "asaConnectionString\s*=\s*""([^""]*)"""
		oRegex.IgnoreCase = True
		Set oMatches = oRegex.Execute(sContents)
		Application.Lock
		For Each oMatch In oMatches
			Application("adoConn_ConnectionString") = oMatch.SubMatches(0)
			Application("adoConn_CommandTimeout") = 1000
			Application("adoConn_ConnectionTimeout") = 500
		Next
		' abort if the connection string could not be parsed
		If Application("adoConn_ConnectionString") = "" Then
			Response.Write "<P><B class=""error"">Unable to parse the asaConnectionString value from: """ & sPath & "global.asa""... ABORT!</B></P>"
			Response.End
		End If
	Else
		Application.Lock
	End If

	' now we can connect to the database and retrieve the remaining application variables
	sStat = "SELECT	VarName, VarValue FROM tblApplicationVar WHERE Archive = 0"
	Set rsVar = adoOpenRecordset(sStat)
	Do Until rsVar.EOF
		Application(rsVar.Fields("VarName").Value) = rsVar.Fields("VarValue").Value
		rsVar.MoveNext
	Loop
	rsVar.Close
	' calculate the base path (folder ASP nuke is installed in)
	' Response.Write "Root Path = *" & sRootPath & "* Path = *" & sPath & "*<BR>"
	sBasePath = Replace(Mid(sPath, Len(sRootPath) + 1), "\", "/")
	If Right(sBasePath, 1) <> "/" Then sBasePath = sBasePath & "/"
	If Left(sBasePath, 1) <> "/" Then sBasePath = "/" & sBasePath
	' build the absolute nuke root
	If Right(Application("SiteRoot"), 1) = "/" Then
		Application("ASPNukeURL") = Application("SiteRoot") & Mid(sBasePath, 2)
	Else
		Application("ASPNukeURL") = Application("SiteRoot") & sBasePath
	End If
	' Response.Write "Base Path = *" & sBasePath & "*" : Response.End
	Application("ASPNukeBasePath") = sBasePath
	Application("steLoadConfig") = "Y"
	Application.UnLock
End Sub

'------------------------------------------------------------------
' Check to see if the form was posted as multipart (indicating that
' Request.BinaryRead was called (and we cannot access Request.Form)

Private Function steCheckMultipartPost
	Dim sContType, hCutOff

	sContType = Request.ServerVariables("CONTENT_TYPE")
	hCutOff = instr(sContType, ";")
	if hCutOff > 0 then
		sContType = UCase(Trim(Left(sContType, hCutOff - 1)))
	else
		sContType = UCase(Trim(sContType))
	end if
	' return true if it is a Multipart post (false otherwise)
	steCheckMultipartPost = (sContType = "MULTIPART/FORM-DATA")
End Function
%>